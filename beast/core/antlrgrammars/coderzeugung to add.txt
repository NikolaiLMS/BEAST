//structs
struct vote_single { unsigned int arr[V]; };
struct vote_double {unsigned int arr[V][C]; };

code.add("//split array");
code.add("");
code.add("//get splits cuts through an array of size max");
code.add("unsigned int *getRandomSplitLines(unsigned int splits, unsigned int max) {");
code.add("	unsigned int *split_arr = malloc(splits * sizeof(*split_arr));");
code.add("	");
code.add("	if (splits == 1) {");
code.add("		unsigned int next_split = nondet_uint();");
code.add("		assume(next_split >= 0);");
code.add("		assume(next_split <= (max / 2));");
code.add("		");
code.add("		split_arr[0] = next_split;");
code.add("	} else {");
code.add("		unsigned int last_split = 0;");
code.add("		for (int i = 0; i < splits; i++) {");
code.add("			");
code.add("			unsigned int next_split = nondet_uint();");
code.add("			assume(next_split >= last_split);");
code.add("			assume(next_split <= max);");
code.add("			");
code.add("					");
code.add("		unsigned int debugHier =max + 1;");
code.add("			");
code.add("			split_arr[i] = next_split;");
code.add("			last_split = next_split;");
code.add("		}");
code.add("		");
code.add("		unsigned int *splitLines;");
code.add("		splitLines = split_arr;");
code.add("		");
code.add("		for (int i = 0; i < splits; i++) {");
code.add("			unsigned int debugrandom = splitLines[i];");
code.add("		}");
code.add("	}");
code.add("	return split_arr;");
code.add("}");
code.add("");
code.add("//start is inclusive, stop is exclusive");
code.add("struct vote_single splitOne(unsigned int votes[V], unsigned int start, unsigned int stop) {");
code.add("	static unsigned int sub_arr[V];");
code.add("	");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		sub_arr[i] = C;");
code.add("	}");
code.add("	");
code.add("	if(start == stop) { //the sub array should be empty");
code.add("		struct vote_single toReturn;");
code.add("		");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			toReturn.arr[i] = sub_arr[i];");
code.add("		}");
code.add("		");
code.add("		return toReturn;");
code.add("	} else {");
code.add("");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			if ((i >= start) && (i < stop)) {");
code.add("				sub_arr[i - start] = votes[i];");
code.add("			}");
code.add("		}");
code.add("	");
code.add("		//struct vote_single toReturn = {sub_arr};");
code.add("		");
code.add("		struct vote_single toReturn;");
code.add("		");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			toReturn.arr[i] = sub_arr[i];");
code.add("		}");
code.add("		");
code.add("		return toReturn;");
code.add("	}");
code.add("}");
code.add("");
code.add("//start is inclusive, stop is exclusive");
code.add("//used for 2 dim arrays");
code.add("struct vote_double splitTwo(unsigned int votes[V][C], unsigned int start, unsigned int stop) {");
code.add("	static unsigned int sub_arr[V];");
code.add("	");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			sub_arr[i][j] = C;");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	if(start == stop) { //the sub array should be empty");
code.add("		struct vote_double toReturn;");
code.add("		");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			for(int j = 0; j < V; j++) {");
code.add("				toReturn.arr[i][j] = sub_arr[i][j];");
code.add("			}");
code.add("		}");
code.add("		");
code.add("		return toReturn;");
code.add("	} else {");
code.add("");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			if ((i >= start) && (i < stop)) {");
code.add("				for(int j = 0; j < C; j++) {");
code.add("					sub_arr[i - start][j] = votes[i][j];");
code.add("				}");
code.add("			}");
code.add("		}");
code.add("		");
code.add("		struct vote_double toReturn;");
code.add("		");
code.add("		for (int i = 0; i < V; i++) {");
code.add("			for(int j = 0; j < V; j++) {");
code.add("				toReturn.arr[i][j] = sub_arr[i][j];");
code.add("			}");
code.add("		}");
code.add("		");
code.add("		return toReturn;");
code.add("	}");
code.add("}");


//split array ende


//concatination

code.add("struct vote_single concatOne(unsigned int votesOne[V], unsigned int sizeOne, unsigned int votesTwo[V], unsigned int sizeTwo) {");
code.add("	static unsigned int sub_arr[V];");
code.add("	");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		sub_arr[i] = C;");
code.add("	}");
code.add("	");
code.add("	for(int i = 0; i < sizeOne; i++) { //limit the size to the upper bound V");
code.add("		if (i < V) {");
code.add("			sub_arr[i] = votesOne[i];");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	for(int i = 0; i < sizeTwo; i++) { //limit the size to the upper bound V");
code.add("		if (sizeOne + i < V) {");
code.add("			sub_arr[sizeOne + i] = votesTwo[i];");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	struct vote_single toReturn;");
code.add("		");
code.add("	for (int i = 0; i < V; i++) {");
code.add("		toReturn.arr[i] = sub_arr[i];");
code.add("	}");
code.add("		");
code.add("	return toReturn;");
code.add("	");
code.add("}");
code.add("");
code.add("struct vote_double concatTwo(unsigned int votesOne[V][C], unsigned int sizeOne, unsigned int votesTwo[V], unsigned int sizeTwo) {");
code.add("	static unsigned int sub_arr[V];");
code.add("	");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			sub_arr[i][j] = C;");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	for(int i = 0; i < sizeOne; i++) { //limit the size to the upper bound V");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			if (i < V) {");
code.add("				sub_arr[i][j] = votesOne[i][j];");
code.add("			}");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	for(int i = 0; i < sizeTwo; i++) { //limit the size to the upper bound V");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			if (sizeTwo + i < V) {");
code.add("				sub_arr[i][j] = votesTwo[i][j];");
code.add("			}");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	struct vote_double toReturn;");
code.add("		");
code.add("	for (int i = 0; i < V; i++) {");
code.add("		for (int j = 0; j < C; j++) {");
code.add("			toReturn.arr[i][j] = sub_arr[i][j];");
code.add("		}");
code.add("	}");
code.add("		");
code.add("	return toReturn;");
code.add("}");

//permutation code start

code.add("struct vote_single permutateOne(unsigned int votes[V], unsigned int length) {");
code.add("	static unsigned int sub_arr[V];");
code.add("	");
code.add("	static unsigned int already_used_arr[V];");
code.add("		");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		sub_arr[i] = C;");
code.add("	}");
code.add("	");
code.add("	");
code.add("	for(int i = 0; i < length; i++) {");
code.add("		unsigned int new_index = nondet_uint();");
code.add("		assume((new_index >= 0) && (new_index < length));");
code.add("		");
code.add("		for(int j = 0; j < i; j++) {");
code.add("			assume(new_index != already_used_arr[j]);");
code.add("		}");
code.add("		");
code.add("		already_used_arr[i] = new_index;");
code.add("		");
code.add("		sub_arr[new_index] = votes[i];");
code.add("	}");
code.add("	");
code.add("	struct vote_single toReturn;");
code.add("		");
code.add("	for (int i = 0; i < V; i++) {");
code.add("		toReturn.arr[i] = sub_arr[i];");
code.add("	}");
code.add("		");
code.add("	return toReturn;");
code.add("	");
code.add("}");
code.add("");
code.add("struct vote_double permutateTwo(unsigned int votes[V][C], unsigned int length) {");
code.add("	static unsigned int sub_arr[V][C];");
code.add("	");
code.add("	static unsigned int already_used_arr[V];");
code.add("		");
code.add("	for(int i = 0; i < V; i++) { //set all to C in the beginning");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			sub_arr[i][j] = C;");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	");
code.add("	for(int i = 0; i < length; i++) {");
code.add("		unsigned int new_index = nondet_uint();");
code.add("		assume((new_index >= 0) && (new_index < length));");
code.add("		");
code.add("		for(int j = 0; j < i; j++) {");
code.add("			assume(new_index != already_used_arr[j]);");
code.add("		}");
code.add("		");
code.add("		already_used_arr[i] = new_index;");
code.add("		");
code.add("		for(int j = 0; j < i; j++) {");
code.add("			sub_arr[new_index] = votes[i];");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	struct vote_double toReturn;");
code.add("		");
code.add("	for (int i = 0; i < V; i++) {");
code.add("		for(int j = 0; j < C; j++) {");
code.add("			toReturn.arr[i][j] = sub_arr[i][j];");
code.add("		}");
code.add("		toReturn.arr[i] = sub_arr[i];");
code.add("	}");
code.add("		");
code.add("	return toReturn;");
code.add("}");

//intersect

code.add("struct stack_result intersect(stack_result one, stack_result two) {");
code.add("	static struct stack_result toReturn;");
code.add("	");
code.add("	for (int i = 0; i < C; i++) {");
code.add("		toReturn.arr[i] = 0;");
code.add("	}");
code.add("	");
code.add("	for (int i = 0; i < C; i++) {");
code.add("		if (one.arr[i] && two.arr[i]) {");
code.add("			toReturn.arr[i] = 1;");
code.add("		}");
code.add("	}");
code.add("	");
code.add("	return toReturn;");
code.add("}");