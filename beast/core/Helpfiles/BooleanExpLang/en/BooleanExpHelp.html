<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BooleanExpLang explanation</title>
</head>
<body>
<h1>Introduction</h1>
The FormalPropertyEditor used a special language, cak
<h1>Language contructs: Reference</h1>
<h2>Refering to voters, candidates or seats</h2>
When testing election descriptions for properties, it is often the case that one wants to formulate
these properties while refering to a specific voter, candidate or seat. Often it is the case that one wants
to make statements regarding the state of one of these types before the election and its impact on the election result.
There are two ways one can go about refering to a specific type in BooleanExpLang: Via symbolic variables or by specifying
a position.
<h3>Symbolic variables</h3>
Symbolic variables represent any voter, candidate or seat and thus give a possibility to refer to the same type
in several different paces. This enables the user to identify given type instances. Symbolic variables
are controlled by the area right under the toolbar. To add one, one must simply click on the add-button and
supply a unique name and a type. Afterwards, it is possible to refer to the created symbolic variable in both
pre and post property descriptions.
<div class="example">
Test if there is one voter v whose vote always wins the election. Define a symbolic variable v. Define as a
post property: ELECT1 == VOTES1(v);
</div>
<h3>Type at Position</h3>
It is sometimes helpful if one can refer to a type by its position amongst all other instances of the same type.
For example, one might want to refer to the first voter, candidate, or seat. This can by achieved using the AT_POS
notation: To refer to a voter at a specific position, simply type VOTER_AT_POS(pos).  Replace pos by the
desired position, starting at 0. It works analogously for candidates
and seats: CAND_AT_POS and SEAT_AT_POS. Notice the abbreviation used: CAND instead of CANDIDATE. This saves typing
and also highlights the word can which is a nice morale boost every time one writes this construct.
It is VERY IMPORTANT to note that the error checker doesn't check bounds on these passed numbers.
This means that if the user types VOTER_AT_POS(5), yet tests the property for less than five voters,
the resulting behaviour is undefined. Instead of a simple integer, any legal expression which
results in an integer, such as sums involving constants
can be passed to the AT_POS expression.
<div class="example">
    Test if the candidate at position 0 always wins: ELECT1 == CAND_AT_POS(0);
    Test if the last candidate always wins: ELECT1 == CAND_AT_POS(C - 1);
</div>
<h2>Numbers and sums</h2>
It is often helpful to be able to write and compare sums, products etc of integer values. BooleanExpLang enables
addition, subtraction, multiplication and divisions. These can be nested arbitrarily. Their results can be used
wherever an integer value is expected, such as when refering to a type via its position or when comparing
values. It is thus possible to write properties such as 2 != 1 + 1. This will obivously always return false. These
sums and products can contain any expression which evaluates to integers, such as constants or
VOTE_SUM_FOR_CANDIDATE().
<div class="example">
    An expression which will always be true: 2 == 2 * 1;
    A complicated, probably useles, but nevertheless allowed expression: V == C + 3 / S - 4 * VOTE_SUM_FOR_CANDIDATE1(c);
    Using a sum to refer to a candidate via position: CAND_AT_POS(C / 2) == c;
</div>
<h2>Comparators</h2>
expressions can be compared if and only if their types are the same: candidates with candidates, integers with integers,
etc. BooleanExpLang supports all common comparison types:
<ul>
    <li>Equality: ==</li>
    <li>InEquality: !=</li>
    <li>Less than: <</li>
    <li>Less than or equal: <=</li>
    <li>Greater than: ></li>
    <li>Greater than or equal: >=</li>
</ul>
When using greater/lesser comparisons with voters, candidates or seats what's compared is their placement. So,
VOTER_AT_POS(0) < VOTER_AT_POS(1) would be true, whereas CAND_AT_POS(5) >= CAND_AT_POS(6) wouldn't be.
<h2>Quantors</h2>
May times, one wants to define a property which should hold for all or at least one Voter,Candidate or Seat.
This can be accomplished using quantors.
<h3>For all</h3>
To define that a property should hold for all instances of a type, one can use the FOR_ALL constructs.
These exist for the three most important types: voters, candidates and seats:
<ul>
    <li>FOR_ALL_VOTERS() :</li>
    <li>FOR_ALL_CANDIDATES() :</li>
    <li>FOR_ALL_SEATS() :</li>
</ul>
All three expect an as of yet undefined symbolic variable as an argument passed between the brackets.
In the boolean Expression following the colon, this symbolic variable can be used to describe a
property which needs to hold for all variables of the same type.
<div class="example">
    All voters vote for candidate at position 0: FOR_ALL_VOTERS(v) : VOTES1(v) == CAND_AT_POS(0);
    ALL candidates have at least one vote: FOR_ALL_CANDIDATES(c) : VOTE_SUM_FOR_CANDIDATE1(c) > 0;
</div>
<h3>There exists</h3>
If one wants to define a property which holds for at least one voter, candidate or seat one can use
the THERE_EXISTS contructs. Their are, analogously to the FOR_ALL expressions, one for each type:
<ul>
    <li>EXISTS_ONE_VOTER() :</li>
    <li>EXISTS_ONE_CANDIDATE() :</li>
    <li>EXISTS_ONE_SEAT() :</li>
</ul>
They each expect an as of yet undefined symbolic variable to be passed between the brackets. This variable
can then be used in the boolean expression following the colon to define a property which must hold for
at least one voter/candidate/seat.
<div class="example">
    <ul>
        <li>There exists a least one voter who votes for the first
        candidate: EXISTS_ONE_VOTER(v) : VOTES1(v) == CAND_AT_POS(0);
        </li>
        <li>
        For each seat there exists one candidate occupying this seat:
        FOR_ALL_SEATS(s) : EXISTS_ONE_CANDIDATE(c) : ELECT1(s) == c;
        </li>
    </ul>
</div>
<h2>Binary boolean relationships</h2>
Binary boolean relationships are very common when formulating boolean expressions. BooleanExpLang provides the most
common and useful ones:
<ul>
    <li>Logical And: &&</li>
    <li>Logical Or: ||</li>
    <li>Implication: ==></li>
    <li>Aquivalency: <==></li>
</ul>
Using these, two boolean Expressions can be combined to produce a third one.
<div class="example">
    <ul>
        <li>
            A candidate wins if and only if he has more than half the votes:
            ELECT1 == c <==> VOTE_SUM_FOR_CANDIDATE1(c) > V/2;
        </li>
        <li>
            If a candidate has more than 2 and less then 5 votes, the first voter votes for him:
            (VOTE_SUM_FOR_CANDIDATE1(c) > 2 && VOTE_SUM_FOR_CANDIDATE1(c) < 5) ==> VOTES1(VOTER_AT_POS(0)) == c;
        </li>
    </ul>
</div>
</body>
</html>