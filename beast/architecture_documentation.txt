This document describes the architecture for beast,
with most attention to the logical throughline and suggestions
on where to start if a dev wants to implement new features

In general, the project has two halves: 
- The functionality of beast, such as 
	code generation, 
	calling cbmc, 
	and giving the results back, 
	
which is in the packages edu.pse.beast.api.*

And the GUI, which uses this api 

which is in the packages edu.pse.beast.gui.*

The gui is implemented in javafx, which uses fxml files created
with GLUON scenebuilder to describe the gui.

The fxml files can be found in src/main/resources/edu/pse/beast/*.fxml

although for example, the beastworkspace is part of the gui, and the 
saving and loading functionality is part of the api. However,
the saving loading functionality knows about beastworkspace so it
can persist it. In general, there are a few cases where the separation
probably isn't 100% accurate.

The GUI:

If the user wants to start the tool through the gui,
the programm starts execution in the class
edu.pse.beast.gui.BeastWithGuiApplicationClass

which build the main gui controller 

edu.pse.beast.gui.BeastGUIController

which contains all the gui startup logic, builds the other gui elements,
and links them up to the edu.pse.beast.gui.workspace.beastworkspace.

The most important class for understanding the gui is

edu.pse.beast.gui.workspace.BeastWorkspace

which is called into by all other gui elements. The workspace
embodies a kind of "session" element, storing opened election descriptions,
property descriptions, run, run results, etc. 

If any of the gui elements want to effect some change such as load another 
election description or update the code of a property or launch a 
cbmc test run, they call into beastworkspace. Beastworkspace manages
the state and then notices the gui elements which can register as 
WorkspaceUpdateListener.

This seperation isn't 100% clean, and sometimes the gui controller will do some
work before calling into the beastworkspace. This could be cleaned up.

Another discrepancy in the gui architecture is the following:
The main gui controller, BeastGUIController, loads one big fxml
(BeastGUI.fxml), which contains all the gui controlls for the sub
controllers such as edu.pse.beast.gui.ceditor.CElectionEditor.

This means, the controlls get injected into  BeastGUIController, which passes
them onto the other controllers through their constructors.

This can be made more elegant by moving the control panes for the seperate controls
into different fxml files, and using FXMLLoader to load these fxml files.

I started doing this later with the edu.pse.beast.gui.testconfigeditor.TestConfigTopLevelGUIHandler.

This code

private TestConfigGuiController testConfigGuiController;
	private FXMLLoader testConfigFXMLLoader = new FXMLLoader(
			getClass().getResource(testConfigDetailFXML));
			
loads the file testConfigDetailFXML, and the javafx subsystem injects the correct
controlls directly into TestConfigGuiController (for example).

OPTIONS

Options are local configurations such as font size or, in the case of windows,
where the VsDevCmd is stored. The implementation can be found under

edu.pse.beast.gui.options.*

BEAST Api

The part of beast which implements all the functionality such as generating the
code and communicating with beast could also be used without the gui.

CODE GENERATION

the cbmc code generation functions as such:

edu.pse.beast.api.codegen.cbmc.CBMCCodeGenerator gets passed
the CElectionDescription, PreAndPostPropertyDescriptions, and
CodeGenOptions. Then, it generates the voting function which
takes a struct as input and returns a struct.

The property description is turned into an AST by first using antlr
to parse it and walk through the tree generated by antlr with 
edu.pse.beast.api.codegen.booleanExpAst.BooleanCodeToAST.

BooleanCodeToAST generates a special AST which is then used to
generate the cbmc code using 

CBMCMainGenerator which in turn uses CodeGenASTVisitor
to visit each node in the generated ast and generate the code.

most code is generated by using a template in 

edu.pse.beast.api.codegen.code_template.templates

